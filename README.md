# Addis Software Summer Internship Test Project

> Name - Tewodros Berhanu
> Hosted frontend - <https://addis-software-test-project-tau.vercel.app/>

This is my project submissiom for the internship program.
The app is a simple react app that uses Mirage.js as the backend mock, with a list of songs obtained from apple music public API.

## Project Structure

### Backend Mock(Mirage) - `./src/mirage`

Contains the backend APIs for the basic CRUD functionality. The base list of songs is obtained from `songs.json`, which is autogenerated on app start by `./src/mirage/data/fetch-songs.ts` (`npm start` script runs this first).

The songs are fetched from two sources:

1. "<https://itunes.apple.com/us/rss/topsongs/limit=100/json>" provides a list of the top 100 songs on iTunes
2. "<https://itunes.apple.com/search?album={album_name}>" which is the public search API, where it also searches for songs from a few,selected albums

The songs are then saved to `songs.json`, which is then used by the mirage backend mock.
*(`songs.json` acts like a source db to fetch an initial list of songs from)*

### Frontend

The frontend uses Redux-toolkit and Redux-saga for state management and API interaction
The main store can be found in `./src/store/store.ts` and `./src/store/songs/` holds the song reducers(slice), saga and type.

`index.tsx` is the main entrypoint to the app, `app.tsx` is the main component, and all subcomponents can be found in `./src/components`

## Features

- [x] Mirage.js mocked api with fully functional CRUD functionality (persists until page reload since Mirage is an in-memory server)
- [x] List of paginated songs, with offset based pagination that is backend driven. (backend only serves songs on the current page until we change the page on the UI)
- [x] Redux-toolkit and Redux-Saga for state management
- [x] Emotion/Syled styling with light and dark themes
- [x] Locally stored list of favorite songs and a favorites songs list using react local state (useState - *another requirement* ).
- [x] Placeholder image served from the public folder (loaded as an image using webpack - *one of the requirements specified is special file specific rules for webpack*)
- [x] Environment variables for the API base url, defined in `.env` file and loaded using `dotenv-webpack` plugin (setup in `webpack.config.js`).
- [x] Collapsible sidebar for navigation and showing song metadata
- [x] Now playing functionality - shows the currently playing song in the bottom bar and sidebar. (looks kind of like aimp3 if you're familiar) **Note: No audio playback at the moment**
- [x] Hosted frontend on Vercel: at"<https://addis-software-test-project-tau.vercel.app/>"

## Tech Stack

Mirage.Js backend
React + TS + Webpack + Redux frontend

## API endpoints

The API endpoints are defined in `./src/mirage/server.ts` and are used to mock the API responses.

| Endpoint | Description |
|----------|-------------|
| `/api/songs` | Get all songs |
| `/api/songs?limit={limit}&page={page}` | Get songs with pagination |
| `/api/songs/:id` | Get a song by id |
| `/api/songs` | Create a new song (autogenerated id) |
| `/api/songs/:id` | Update a song by id |
| `/api/songs/:id` | Delete a song by id |

## Deployment

The frontend is hosted using Vercel: at"<https://addis-software-test-project-tau.vercel.app/>"

## Webpack

My webpack configuration has a few sections, and has a few functions so  I'll try to explain them by going over each field one by one

- entry: Entrypoint of the app. This is the root of the react SPA, `./src/index.tsx`. The Mirage.js server is also started from here. (Theme and redux-store providers are also setup here)

- output: Output directory for the built files. `dist` is the default output directory.

- resolve: This is only ts and tsx files, but just as a catch all i've also included js and jsx files to avoid any issues just in case.

- devtool: using source map to make debugging actually doable

- module: This is the main section for the rules on how to handle different file types.
  - ts and tsx files are handled by the ts-loader package since they need to be compiled to js before being used by the browser.
  - js files are handled by the source-map-loader package to generate source maps for debugging. (not jsx, because they'll have already been compiled to js anyway)
  - css files are handled by the style-loader and css-loader packages to be able to use css in the app directly (only one .css file was used - `./src/index.css`)
  - .png and .avif files are handled by the asset/resource loader to be able to use them as images in the app. (the images are stored in the public folder, **and one .avif image is loaded in `./src/components/SongComponent.tsx`** using this rule)

- plugins: This is the main section for the plugins to be used in the build process.
  - HtmlWebpackPlugin: to generate the html file for the app. This is to generate the final output that will be served by the server (in this case Vercel, which serves `./dist/index.html` after running `npm run build`).
  - DotenvWebpackPlugin: to load the `.env` file and make the variables available to the webpack build process (used to define the `API_BASE_URL` variable).

- optimization:
  - splitChunks: to split the chunks into smaller chunks to be able to use lazy loading.
  - minimize: to minimize the built files to be able to use less bandwidth and make the app load faster.

- devServer: Server that webpack runs on.
  - static: This is the static directory for the app. to serve the image during dev
  - port: This is the port for the development server. runs on 3000 by default
  - open: to open the app in the browser after the build is complete
  - hot: hot reload - godsend during dev

## AI Use

No large sections of the code were written by AI, but I did use it to research and lookup pieces I was not familiar/experienced in. These are the parts I used AI for -

- Song source - Never would've found out iTunes had a public API for their top 100 songs and album searching. It also suggested the album placeholder image (ChatGpt search).
- CSS styling for components - This was done in 2 days, I didn't want to spend too much time tweaking css values, so some amount of the initial CSS was generated by AI. Changed a lot of things to fit my design and to ensure it's responsive. Just styling so I tried checking it on different sized screens to make sure it's responsive enough as well
- Webpack research - I've only setup webpack fully and manually once before, I used AI to lookup some things, and to check my work after I finished. It helped me identify a few things I had gotten wrong (for eg: i originally had my output folder as `./public` instead of `./dist`, caused some issues with the build process and the image not being served during dev)
- Loading Spinner - AI generated the initial version, which was fullscreen and had positioning issues. Made a few edits to reach this version
- Overall searching - I use ChatGPT as a search engine more than I use it to generate code, rarely use google anymore for research unless I'm looking for something specific

## Running Locally

To run the app locally:

### Development

```bash
npm install
npm run start
```

### Production

```bash
npm run build
```

Both `npm run start` and `npm run build` will run the `npm run fetch-songs` script first to fetch the songs from the iTunes API and save them to `./src/mirage/data/songs.json`. (The file you see in the repo is the result of running this script. It's not really used directly by the app (it generates another file when it's run locally or in prod), it's just there as a demonstration of what the script will result in)
